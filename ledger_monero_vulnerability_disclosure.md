Hello,

I would like to report what I believe is a critical security vulnerability I found in
the Monero transaction signing code for Ledger hardware wallet.

The monero app in question:  https://github.com/LedgerHQ/ledger-app-monero.git
Commit 7d6c5f5573c4c83fe74dcbb3fe6591489bae7828, tag: 1.4.2 

Tldr: It is possible to construct a decrypting oracle by using `sc_sub()` and `mlsag_sign()` 
commands. With the decrypting oracle it is possible to obtain the wallet spending
private key `k^s` (or b) in a negligible time.

I found the vulnerability on 2. Jan 2020 and you are the first person I am reporting it to.
I would like to use a responsible disclosure process, as described in https://donjon.ledger.com/bounty/ 

However, as I am working in academia, I would like to reserve a right to publish the 
vulnerability description in around 90 days after the vulnerability notification 
(or less if you manage to fix it sooner).
Similarly, I would like to present my findings in an academic paper focused on 
the monero transaction signing. 

I've checked the vulnerability several times and I think it is valid. 
However, please pardon me if I missed something and this is a false alarm. 

## Vulnerability description 

Let's assume the device is in the transaction building state, i.e., 
the `monero_apdu_open_tx()` function was called. The attacker thus has a valid HMAC for 
the `C_FAKE_SEC_SPEND_KEY`.

The `sc_sub()` function is located in the `src/monero_key.c`, line 430.
The function takes two encrypted-and-hmaced values: 
`{enc(a), hmac(enc(a)), enc(b), hmac(enc(b))}`

The Hmacs are checked, input values are decrypted, and eventually it returns:
`{enc(a-b), hmac(enc(a-b))}`.

Notice that when the `sc_sub` is called with the same parameters `{a, a}`, it returns
encrypted and hmaced version of 0. 
I.e., `sc_sub(enc(a), hmac(enc(a)), enc(a), hmac(enc(a))) -> {enc(0), hmac(enc(0))}`,
for some random `enc(a), hmac(enc(a))`, that can be obtained by using any encrypted
scalar value from the current protocol run or by calling `monero_apdu_generate_keypair()`.

The `{enc(0), hmac(enc(0))}` is a valuable information as it can be used as a known input
to other functions. 
When used with the `monero_apdu_mlsag_sign()` from the `src/monero_mlsag.c`, line 96, 
we obtain a decryption oracle.

The `monero_apdu_mlsag_sign()` takes two encrypted-and-hmaced values: `alpha, xin`.
It checks the HMACs, decrypts the values, and computes:
`ss = (alpha - c * xin) % l`, where `c` is a constant stored in the device state and
the `l` is EC group order. 
The function returns `ss` in the clear text.
 
Thus if we call `monero_apdu_mlsag_sign(enc(x), hmac(enc(x)), enc(0), hmac(enc(0)))` 
we obtain the `x` value.

The decryption oracle can be used to decrypt all encrypted values sent to the host in the 
protocol run, e.g., UTXO private spending keys, derivations. Having the keys in the 
clear-text enables to spend UTXOs without using the hardware wallet.

Moreover, it is possible to obtain the main wallet spending private key in the 
following way:

Observe the `monero_io_fetch_decrypt_key()` function, from the `src/monero_io.c`, line 258.
If the function decrypting the encrypted input parameter finds the `C_FAKE_SEC_SPEND_KEY`,
the wallet spend key `b` is used instead.

Thus if we call `monero_apdu_mlsag_sign(C_FAKE_SEC_SPEND_KEY, hmac(C_FAKE_SEC_SPEND_KEY), enc(0), hmac(enc(0)))` 
the function returns directly the spend private key `b`.

Summary:
- call `monero_apdu_open_tx()`, obtain `hmac(C_FAKE_SEC_SPEND_KEY)`
- call `monero_apdu_generate_keypair()`, obtain `{enc(x), hmac(enx(x))}`, where `x` is unknown.
- call `sc_sub(enc(x), hmac(enc(x)), enc(x), hmac(enc(x)))`, obtain `{enc(0), hmac(enc(0))}`
- call `monero_apdu_mlsag_sign(C_FAKE_SEC_SPEND_KEY, hmac(C_FAKE_SEC_SPEND_KEY), enc(0), hmac(enc(0)))`, obtain `b`

## Encryption oracle
This section describes how to obtain an encrypt-and-hmac oracle. It is not required 
for the described critical vulnerability to work, but it may be considered as it may be 
used later in another potential vulnerability. 

Setup:
- Obtain `{enc(0), hmac(enc(0))}` as above

- Call `monero_apdu_generate_keypair()` function to obtain a sequence of random encrypted
and hmaced scalar values: `S1 = {enc(a_i), hmac(enc(a_i))}_i`

- Call the decrypting oracle on each element of S1 to obtain a sorted sequence:
`S2 = {a_i, enc(a_i), hmac(enc(a_i))}_i`, i.e., `a_i <= a_j`.

- Call `sc_sub(a_i, a_j)` where `a_i < a_j && a_j != 0`. 
The result `x_i` is strictly less than `a_i` and `a_j`. 
By applying this algorithm repeatedly, we obtain `{enc(1), hmac(enc(1))}`, as the
algorithm is essentially the `GCD(a_i, a_j)`. 

- Construct an integer base: `IB = {2^i, enc(2^i), hmac(enc(2^i))}_{i \in [0, 255]}`, 
by using the `{enc(1), hmac(enc(1))}` and `sc_add()` calls. 
The base can be constructed in 256 function calls.

The complexity of this algorithm depends on the probability that `gcd(a_i, a_j)=1`, which
should be the case with probability ~ 0.608162
(The probability was computed by a simulation with 1000000 iterations, where
two random 256-bit numbers were generated mod group order, if gcd was 1, counter was incremented).

Similarly, I computed the average number of calls to the `sc_sub` required to obtain encryption of 1
is 4005.

Encryption oracle:
Use the integer base IB to construct `{enc(x), hmac(enc(x))}` for known x
by calling `sc_add` with the elements from the integer base IB. 

The complexity is the Hamming weight of the x.


------------------------------------

Dusan Klinec (ph4r05)
- contact: ph4r05 -at- gmail.com
- GPG ID: CCBCE103
- GPG fingerprint: AB35 9D7F B6BF B9AA 542C  EAAB 6337 E118 CCBC E103

