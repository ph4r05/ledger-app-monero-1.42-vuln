Hello,

I would like to report what I believe is a critical security vulnerability I found in
the Monero transaction signing code for Ledger hardware wallet.

The monero app in question:  https://github.com/LedgerHQ/ledger-app-monero.git
Commit 7d6c5f5573c4c83fe74dcbb3fe6591489bae7828, tag: 1.4.2 

Tldr: It is possible to construct a decrypting oracle by using `sc_sub()` and `mlsag_sign()` 
commands. With the decrypting oracle it is possible to obtain the wallet spending
private key `k^s` (or b) in a negligible time.

I found the vulnerability on 2. Jan 2020 and you are the first person I am reporting it to.
I would like to use a responsible disclosure process, as described in https://donjon.ledger.com/bounty/ 

However, as I am working in academia, I would like to reserve a right to publish the 
vulnerability description in around 90 days after the vulnerability notification 
(or less if you manage to fix it sooner).
Similarly, I would like to present my findings in an academic paper focused on 
the Monero transaction signing. 

I've managed to extract the spendkey with the `poc.py` with the updated Ledger device.
PoC just requires connected Ledger device, with PIN entered and Monero app selected.
PoC then manages to extract the spend key without user noticing.
No confirmation is required, display shows no change.

## Vulnerability description 

Let's assume the device is in the transaction building state, i.e., 
the `monero_apdu_open_tx()` function was called. The attacker thus has a valid HMAC for 
the `C_FAKE_SEC_SPEND_KEY`.

Now I describe how to obtain a decryption oracle, then the spend key extraction.

### Decryption oracle
The `sc_sub()` function is located in the `src/monero_key.c`, line 430.
The function takes two encrypted-and-hmaced values: 
`{enc(a), hmac(enc(a)), enc(b), hmac(enc(b))}`

The Hmacs are checked, input values are decrypted, and eventually it returns:
`{enc(a-b), hmac(enc(a-b))}`.

Notice that when the `sc_sub` is called with the same parameters `{a, a}`, it returns
encrypted and hmaced version of 0. 
I.e., `sc_sub(enc(a), hmac(enc(a)), enc(a), hmac(enc(a))) -> {enc(0), hmac(enc(0))}`,
for some random `enc(a), hmac(enc(a))`, that can be obtained by using any encrypted
scalar value from the current protocol run or by calling `monero_apdu_generate_keypair()`.

The `{enc(0), hmac(enc(0))}` is a valuable information as it can be used as a known input
to other functions. 
When used with the `monero_apdu_mlsag_sign()` from the `src/monero_mlsag.c`, line 96, 
we obtain a decryption oracle.

The `monero_apdu_mlsag_sign()` takes two encrypted-and-hmaced values: `xin, alpha`.
It checks the HMACs, decrypts the values, and computes:
`ss = (alpha - c * xin) % l`, where `c` is a constant stored in the device state and
the `l` is EC group order. 
The function returns `ss` in the clear text.
 
Thus if we call `monero_apdu_mlsag_sign(enc(0), hmac(enc(0)), enc(x), hmac(enc(x)))` 
we obtain the `x` value.

The decryption oracle can be used to decrypt all encrypted values sent to the host in the 
protocol run, e.g., UTXO private spending keys, derivations. Having the keys in the 
clear-text enables to spend UTXOs without using the hardware wallet.


### Wallet Spend key extraction 
It is also possible to obtain the main wallet spending private key in the following way:

Observe the `monero_io_fetch_decrypt_key()` function, from the `src/monero_io.c`, line 258.
If the function decrypting the encrypted input parameter finds the `C_FAKE_SEC_SPEND_KEY`,
the wallet spend key `b` is used instead.

The function `monero_io_fetch_decrypt_key()` is present only in certain calls operating on 
encrypted function parameters, thus we cannot just call
`monero_apdu_mlsag_sign(enc(0), hmac(enc(0)), C_FAKE_SEC_SPEND_KEY, hmac(C_FAKE_SEC_SPEND_KEY))` 
to obtain the spend private key `b` as the `monero_io_fetch_decrypt_key()` is not used in this function.

However, the `monero_apdu_derive_secret_key()` function, `src/monero_key.c`, line 574 contains `monero_io_fetch_decrypt_key`
function call. This function takes the parameters: `{derivation, index, sec}`. 
- `derivation` is decrypted with `monero_io_fetch_decrypt()`
- `sec` is decrypted with `monero_io_fetch_decrypt_key()`
- `index` is just 4 B integer, not HMACed nor encrypted.

The function checks HMACs, decrypts inputs and computes:
`r = H_s(derivation || varint(index)) + sec`, where `r` is returned encrypted and hmaced.

Now, let's call the function in the following way:
`monero_apdu_derive_secret_key(enc(0), hmac(enc(0)), 0, C_FAKE_SEC_SPEND_KEY, hmac(C_FAKE_SEC_SPEND_KEY))`.
The function returns `{enc(r), hmac(enc(r))}` and by using the decryption oracle we get `r`.

We thus have:
`r = H_s(00....00 || varint(0)) + b`. Note that `H_s(00....00 || varint(0))` is a constant and the attacker can compute
it. Thus we obtain `b = r - H_s(00....00 || varint(0))`.

Summary:
- call `monero_apdu_open_tx()`, obtain `hmac(C_FAKE_SEC_SPEND_KEY)`
- call `monero_apdu_generate_keypair()`, obtain `{enc(x), hmac(enx(x))}`, where `x` is unknown.
- call `sc_sub(enc(x), hmac(enc(x)), enc(x), hmac(enc(x)))`, obtain `{enc(0), hmac(enc(0))}`
- call `monero_apdu_derive_secret_key(enc(0), hmac(enc(0)), 0, C_FAKE_SEC_SPEND_KEY, hmac(C_FAKE_SEC_SPEND_KEY))`, obtain `{enc(r), hmac(enc(r))}`
- call `monero_apdu_mlsag_sign(enc(0), hmac(enc(0)), enc(r), hmac(enc(r)))`, obtain `r`
- compute b: `b = r - H_s(00....00 || varint(0))`

We thus obtained the spend key `b`.

For PoC check `poc.py`. Please note it requires `pip install ledgerblue monero_agent`.

## Additional useful observations
Here follows additional and useful gadgets and oracles that might be helpful. 
The following is not required to mount the critical vulnerability. 

### Encryption oracle
This section describes how to obtain an encrypt-and-hmac oracle. It is not required 
for the described critical vulnerability to work, but it may be considered as it may be 
used later in another potential vulnerability. 

Setup:
- Obtain `{enc(0), hmac(enc(0))}` as above

- Call `monero_apdu_generate_keypair()` function to obtain a sequence of random encrypted
and hmaced scalar values: `S1 = {enc(a_i), hmac(enc(a_i))}_i`

- Call the decrypting oracle on each element of S1 to obtain a sorted sequence:
`S2 = {a_i, enc(a_i), hmac(enc(a_i))}_i`, i.e., `a_i <= a_j`.

- Call `sc_sub(a_i, a_j)` where `a_i < a_j && a_j != 0`. 
The result `x_i` is strictly less than `a_i` and `a_j`. 
By applying this algorithm repeatedly, we obtain `{enc(1), hmac(enc(1))}`, as the
algorithm is essentially the `GCD(a_i, a_j)`. 

- Construct an integer base: `IB = {2^i, enc(2^i), hmac(enc(2^i))}_{i \in [0, 255]}`, 
by using the `{enc(1), hmac(enc(1))}` and `sc_add()` calls. 
The base can be constructed in 256 function calls.

The complexity of this algorithm depends on the probability that `gcd(a_i, a_j)=1`, which
should be the case with probability ~ 0.608162
(The probability was computed by a simulation with 1000000 iterations, where
two random 256-bit numbers were generated mod group order, if gcd was 1, counter was incremented).
The simulation code is in `poc_math.sage`

Similarly, I computed the average number of calls to the `sc_sub` required to obtain encryption of 1
is 4005.

Encryption oracle:
Use the integer base IB to construct `{enc(x), hmac(enc(x))}` for known x
by calling `sc_add` with the elements from the integer base IB. 

The complexity is the Hamming weight of the x.

### Scalar value test gadget

- Use `scmultkey(key, G)` call that returns `key * G`. If `key == 0`, then function returns `O`.
- Similarly, if `key==1` then function returns `G`.
- This generalizes to an arbitrary integer test.

### Why removing `sc_sub()` is not enough

The zero element can be obtained also with `sc_add()` only, if `sc_sub` is later removed. 
The `sc_sub()` is not used in the current Monero client code, while it is implemented and available to call in the Ledger.

Idea: `l*x % l = 0` for a random `x != 0`, where `l` is a prime group order.  

- Define `l = 7237005577332262213973186563042994240857116359379907606001950938285454250989`, the group order.
- Call `monero_apdu_generate_keypair()`, obtain `{enc(x), hmac(enx(x))}`, where `x` is unknown.
- Build the following base: `ABS = {enc((2^i)*x), hmac(enx((2^i)*x))}_{i \in [1, 255]}`, by calling `sc_add(enc(x), hmac(enx(x)), enc(x), hmac(enx(x)))`.
  - `sc_add(enc(2^i * x), hmac(enx(2^i * x)), enc(2^i * x), hmac(enx(2^i * x))) = {enc(2^{i+1} * x), hmac(enx(2^{i+1} * x))}`
  - 254 function calls are required
- Construct set `I = \{ i | 2^i % l == 0\}`, it holds the `|I| = 73.`
- Construct `{enc(0), hmac(enx(0))}` by summing the set `{ABS[i], i \in I}`
- Verify by calling `scmult_base(enc(0), hmac(enx(0))) =? O`

For PoC see `poc_math.sage`


### Enc oracle with `sc_add()`
Having the encryption of 0 and the decrypt oracle, we can construct encryption of `x` in the following way.
Idea: use known value and `sc_add()` until `x` is obtained. 

- Call `monero_apdu_generate_keypair()`, obtain `{enc(x), hmac(enx(x))}`, where `x` is unknown.
- Use decrypt oracle to obtain `{a, enc(a), hmac(enx(a))}`, where `a` is now known.
- Construct integer base `ABS = {(2^i)*a, enc((2^i)*a), hmac(enx((2^i)*a))}_{i \in [1, 255]}` as above
- Find integer `z=a^{-1} * x`, convert to binary, construct `I` set as above
- Obtain `{x, enc(x), hmac(enx(x))}` by summing the set `{ABS[i], i \in I}`.

For PoC see `poc_math.sage`

------------------------------------

Dusan Klinec (ph4r05)
- contact: ph4r05 -at- gmail.com
- GPG ID: CCBCE103
- GPG fingerprint: AB35 9D7F B6BF B9AA 542C  EAAB 6337 E118 CCBC E103

